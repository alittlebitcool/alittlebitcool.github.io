---
title: 锁总结
date: 2022-07-27 17:31:50
categories: 开发基础
---

![锁总结图](D:\GitProject\alittlebitcool.github.io\public\img\640.jpg)

### 1.CAS

 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。注意：比较+更新整体是一个原子操作。

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;
    private static final Unsafe unsafe = Unsafe.getUnsafe();// 获取并操作内存的数据。
    private static final long valueOffset;// 存储value在AtomicInteger中的偏移量。

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;// 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。
}
```



### **2. 乐观锁 VS 悲观锁**

悲观锁：

- 认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
- synchronized关键字和Lock的实现类都是悲观锁。
- 适合写操作多的场景，先加锁可以保证写操作时数据正确。

```java
// 悲观锁
public synchronized void test1() {
    // synchronized操作同步资源
}

private ReentrantLock lock = new ReentrantLock();
public void test2() {
    lock.lock();
    // lock操作同步资源
    lock.unlock();
}
```



乐观锁：

- 认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则报错或者自动重试。
- 最常采用的是CAS算法
- 适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

```java
// 乐观锁
private AtomicInteger atomicInteger = new AtomicInteger();
atomicInteger.incrementAndGet();
```

