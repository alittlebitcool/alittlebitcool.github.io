<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络 | YuXingZh Blog</title><meta name="author" content="YuXingZh"><meta name="copyright" content="YuXingZh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分层结构   分层为了每一层专注一件事，相互独立，提高灵活性可替换性。    分层结构   应用层   任务：为计算机提供服务          传输单位：报文         表示层        任务：数据处理(编解码、加密解密、压缩解压缩) 功能：文件传输，访问和管理 协议：FTP，SMTP，DHCP          传输单位：报文         会话层   任务：管理 (建立、维护、">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://alittlebitcool.github.io/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="YuXingZh Blog">
<meta property="og:description" content="分层结构   分层为了每一层专注一件事，相互独立，提高灵活性可替换性。    分层结构   应用层   任务：为计算机提供服务          传输单位：报文         表示层        任务：数据处理(编解码、加密解密、压缩解压缩) 功能：文件传输，访问和管理 协议：FTP，SMTP，DHCP          传输单位：报文         会话层   任务：管理 (建立、维护、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://alittlebitcool.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2023-03-06T08:58:23.000Z">
<meta property="article:modified_time" content="2025-03-06T09:01:06.318Z">
<meta property="article:author" content="YuXingZh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://alittlebitcool.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络",
  "url": "https://alittlebitcool.github.io/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/",
  "image": "https://alittlebitcool.github.io/img/butterfly-icon.png",
  "datePublished": "2023-03-06T08:58:23.000Z",
  "dateModified": "2025-03-06T09:01:06.318Z",
  "author": [
    {
      "@type": "Person",
      "name": "YuXingZh",
      "url": "https://alittlebitcool.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://alittlebitcool.github.io/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YuXingZh Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机网络</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-06T08:58:23.000Z" title="发表于 2023-03-06 16:58:23">2023-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-06T09:01:06.318Z" title="更新于 2025-03-06 17:01:06">2025-03-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><ul>
<li><p>分层结构</p>
</li>
<li><ul>
<li>分层为了每一层专注一件事，相互独立，提高灵活性可替换性。</li>
</ul>
</li>
<li><ul>
<li><p>分层结构</p>
</li>
<li><ul>
<li><p>应用层</p>
</li>
<li><ul>
<li>任务：为计算机提供服务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>传输单位：报文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>表示层</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>任务：数据处理(编解码、加密解密、压缩解压缩)</li>
<li>功能：文件传输，访问和管理</li>
<li>协议：FTP，SMTP，DHCP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>传输单位：报文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>会话层</p>
</li>
<li><ul>
<li>任务：管理 (建立、维护、重连)应用程序之间的会话</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>传输单位：报文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>传输层：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>任务：负责主机两个进程之间的通信</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>功能：端到端提供可靠传输服务，提供流量控制，差错控制，服务质量等管理服务。</li>
<li>协议：TCP，UDP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>传输单位：报文段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>网络层：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>任务：路由和寻址(决定数据在网络的游走路径）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>实现主机与主机之间的通信，也叫点对点（end to end）通信。</li>
<li>功能：路由选择，拥塞控制</li>
<li>设备：路由器</li>
<li>协议：IP，ARP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>传输单位：数据报</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>数据链路层：</p>
</li>
<li><ul>
<li>任务：将网络层传下来的IP数据报组成帧，帧编码和误差纠正控制</li>
<li>功能：链路的建立，拆除，分离。帧定界和帧同步，差错检测。</li>
<li>设备：交换机，网桥</li>
<li>协议：ARQ</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>传输单位：帧</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>物理层：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>任务：透明地传输比特流</li>
<li>为数据端提供传送数据桐庐</li>
<li>设备：集线器，中继器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>传输单位：比特</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzjdbk/p/13028290.html">https://www.cnblogs.com/zzjdbk/p/13028290.html</a></li>
</ul>
</li>
<li><p>地址</p>
</li>
<li><ul>
<li>ABC类地址，网络号和主机号。</li>
</ul>
</li>
<li><p>DDos攻击</p>
</li>
<li><ul>
<li>利用一些被控制的设备对目标网站在较短时间内发起大量请求，大规模消耗目标网站的主机资源，使其无法正常服务。</li>
</ul>
</li>
<li><p>网络传输方式</p>
</li>
<li><ul>
<li><p>单工：又称为单向通信，即只能有一个方向的通信而没有反方向的交互。</p>
</li>
<li><ul>
<li>无线电广播，电视广播</li>
</ul>
</li>
<li><p>半双工：又称为双向交替通信，即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接受）。</p>
</li>
<li><p>全双工：又称为双向同时通信，即通信的双方可以同时发送和接受信息。</p>
</li>
</ul>
</li>
<li><p>交换方式</p>
</li>
<li><ul>
<li><p>电路交换</p>
</li>
<li><p>分组交换</p>
</li>
<li><ul>
<li><p>优点</p>
</li>
<li><ul>
<li>加速传输：后一个分组的存储操作和前一个分组的转发操作并行。简化了存储管理：分组的长度固定，相应的缓冲区大小也固定。减少出错的几率和重发的数据量：分组较短，出错几率减少，重发数据量减少。</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><ul>
<li>存在传输时延。可能会出现失序，丢失，重复分组。需要进行编号工作，工作量大。</li>
</ul>
</li>
</ul>
</li>
<li><p>报文交换</p>
</li>
<li><p>分组交换优缺点</p>
</li>
<li><ul>
<li>优点：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>加速传输：后一个分组的存储操作和前一个分组的转发操作并行。</li>
<li>简化了存储管理：分组的长度固定，相应的缓冲区大小也固定。</li>
<li>减少出错的几率和重发的数据量：分组较短，出错几率减少，重发数据量减少。</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
<li><ul>
<li>存在传输时延。</li>
<li>可能会出现失序，丢失，重复分组。需要进行编号工作，工作量大。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>RTT-Round Trip Time 往返时延</p>
</li>
<li><ul>
<li>数据发送时刻到接收到确认的时刻的差值</li>
</ul>
</li>
<li><p>RTO Retransmission Timeout 超时重传时间）</p>
</li>
<li><p>加密算法</p>
</li>
<li><ul>
<li>对称加密：密钥只有一个加密解密是同一个密码加密速度快。如DES、AES等</li>
<li>非对称加密：加密解密使用不同密钥，发送方获得接收方的公开密钥后，使用公开密钥加密。接收方收到内容用私有密钥解密。更加安全的将公开密钥传输给发送方，运算速度慢。如RSA，DSA等</li>
<li>https采用混合的对称加密的方式，所有传输内容经过对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</li>
</ul>
</li>
<li><p>Session和Cookie的区别</p>
</li>
<li><ul>
<li>Session和Cookie都是用来跟踪浏览器用户身份的绘画方式。</li>
<li>Cookie用来保存用户信息，Session通过服务端记录用户的状态</li>
<li>Cookie一般保存在客户端。Session数据保存在服务端，因而Session的安全性必然更高。</li>
<li>在存储敏感信息的时候不直接写入Cookie中，而是对Cookie信息加密再去服务端进行解密。</li>
<li>Cookie被禁用怎么班，最常用就是利用URL把Session ID直接附加在URL路径后面。</li>
</ul>
</li>
<li><p>正向代理</p>
</li>
<li><ul>
<li>主动方是用户，用来绕过网络限制，访问被封锁的网站、解决跨域问题和隐藏用户访问记录的作用。</li>
<li>客户端向代理服务器发送请求，代理服务器代表客户端向目标服务器请求资源。</li>
</ul>
</li>
<li><ul>
<li>客户端需要明确指定代理服务器，请求的目标服务器对客户端是不可见的。</li>
<li>代理服务器可以缓存请求的资源，提高访问速度。</li>
</ul>
</li>
<li><p>反向代理</p>
</li>
<li><ul>
<li>反向代理的主动方是服务器，主要是提供 负载均衡 、高可用性、SSL加密、安全防护 等作用。</li>
<li>客户端向反向代理服务器发送请求，反向代理服务器根据请求的内容和规则，将请求转发给后端的目标服务器。</li>
</ul>
</li>
<li><ul>
<li>客户端不需要明确指定代理服务器，请求的目标服务器对客户端是透明的。</li>
<li>反向代理服务器可以根据负载均衡算法将请求分发给多个后端服务器，提高系统的性能和可靠性。</li>
</ul>
</li>
<li><p>状态码</p>
</li>
<li><ul>
<li>1xx（信息） ：表示接收到请求，需要继续处理。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>100 Continue：继续，客户端应继续其请求。</li>
</ul>
</li>
<li><p>2xx（成功） ：表示请求已成功被服务器接收、理解和接受。</p>
</li>
<li><ul>
<li>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回。</li>
<li>201 Created：请求已成功，并因此创建了一个新的资源。</li>
<li>204 No Content：无内容，服务器成功处理，但未返回内容。</li>
</ul>
</li>
<li><p>3xx（重定向） ：需要后续操作才能完成这一请求。</p>
</li>
<li><ul>
<li>301 Moved Permanently：永久重定向，请求的资源已被永久移动到新位置。</li>
<li>302 Found：临时重定向，请求的资源临时从不同位置响应。</li>
<li>304 Not Modified：资源未修改，使用缓存的资源。</li>
</ul>
</li>
<li><p>4xx（客户端错误 ）：请求包含错误语法或无法完成。</p>
</li>
<li><ul>
<li>400 Bad Request：客户端请求的语法错误，服务器无法理解。</li>
<li>401 Unauthorized：请求需要用户验证。</li>
<li>403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行它。</li>
<li>404 Not Found：请求的资源无法在服务器上找到。</li>
</ul>
</li>
<li><p>5xx（服务器错误） ：服务器未能实现合法的请求。</p>
</li>
<li><ul>
<li>500 Internal Server Error：服务器内部错误，无法完成请求。</li>
<li>501 Not Implemented：服务器不支持请求的功能。</li>
<li>503 Service Unavailable：服务器暂不可用，可能是服务器过载或停机维护。</li>
</ul>
</li>
</ul>
</li>
<li><p>一个URL从发起到结束经过</p>
</li>
<li><ul>
<li>DNS 解析</li>
</ul>
</li>
<li><ul>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
</li>
<li><p>TCP连接后，可以同时发送几个HTTP</p>
</li>
<li><ul>
<li>设置头字段Connection：Keep-Alive，完成HTTP请求后，就不会断开当前TCP连接。否则已完成就断开，浪费资源。</li>
<li>HTTP1.1把Connection ：close开启持久化</li>
<li>HTTP1.1不支持同时多个请求，HTTP2提供了多路传输，可以同时在同一个TCP连接中进行传输。</li>
<li>不同浏览器可以对同一个域名建立多个TCP连接，来支持多个HTTP同时请求。</li>
<li>HTTP2中Multiplexing可是让TCP中进行多个HTTP请求。</li>
<li>刷新页面不需要重建SSL连接，TCP维持一段时间，SSL用之前的</li>
<li>浏览器对统一Host建立TCP连接限制，如Chrome允许建立6个TCP连接</li>
</ul>
</li>
<li><p>Ping命令</p>
</li>
<li><ul>
<li><p>工作原理：</p>
</li>
<li><ul>
<li>ping 命令发送一个 ICMP Echo 请求到目标主机，然后等待目标主机的 ICMP Echo 回应。</li>
<li>它测量了两个关键的参数：往返时间（RTT）和数据包的丢失率。</li>
<li>RTT表示从发送请求到接收回应所花费的时间。</li>
<li>丢失率表示发送的请求中有多少被目标主机丢弃。</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP请求方法</p>
</li>
<li><ul>
<li><p>GET</p>
</li>
<li><ul>
<li>请求指定的页面信息，并返回实体主体。</li>
</ul>
</li>
<li><p>HEAD</p>
</li>
<li><ul>
<li>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
</ul>
</li>
<li><p>POST</p>
</li>
<li><ul>
<li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。</li>
<li>数据被包含在请求体中。</li>
<li>POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li>
</ul>
</li>
<li><p>PUT</p>
</li>
<li><ul>
<li>从客户端向服务器传送的数据取代指定的文档的内容。</li>
</ul>
</li>
<li><p>DELETE</p>
</li>
<li><ul>
<li>请求服务器删除指定的页面。</li>
</ul>
</li>
<li><p>CONNECT</p>
</li>
<li><ul>
<li>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li>
</ul>
</li>
<li><p>OPTIONS</p>
</li>
<li><ul>
<li>允许客户端查看服务器的性能。</li>
</ul>
</li>
<li><p>TRACE</p>
</li>
<li><ul>
<li>回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
</li>
<li><p>PATCH</p>
</li>
<li><ul>
<li>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</li>
</ul>
</li>
</ul>
</li>
<li><p>转发和重定向的区别</p>
</li>
<li><ul>
<li><p>定义不同</p>
</li>
<li><ul>
<li>请求转发（Forward）：发生在服务端程序内部，当服务器端收到一个客户端的请求之后，会先将请求，转发给目标地址，再将目标地址返回的结果转发给客户端。而客户端对于这一切毫无感知的，这就好比，张三（客户端）找李四（服务器端）借钱，而李四没钱，于是李四又去王五那借钱，并把钱借给了张三，整个过程中张三只借了一次款，剩下的事情都是李四完成的，这就是请求转发。请求重定向（Redirect）：请求重定向指的是服务器端接收到客户端的请求之后，会给客户端返回了一个临时响应头，这个临时响应头中记录了，客户端需要再次发送请求（重定向）的 URL 地址，客户端再收到了地址之后，会将请求发送到新的地址上，这就是请求重定向。这就好像张三（客户端）找李四（服务器端）借钱，李四没钱，于是李四就告诉张三，“我没钱，你去王五那借“，于是张三又去王五家借到了钱，这就是请求重定向。</li>
</ul>
</li>
<li><p>请求方不同</p>
</li>
<li><ul>
<li>请求转发是服务器端的行为，服务器端代替客户端发送请求，并将结果返回给客户端；而请求重定向是客户端的行为，它们的交互流程，如下图所示：</li>
</ul>
</li>
<li><p>数据共享不同</p>
</li>
<li><ul>
<li>请求转发是服务器端实现的，所以整个执行流程中，客户端（浏览器端）只需要发送一次请求，因此整个交互过程中使用的都是同一个 Request 请求对象和一个 Response 响应对象，所以整个请求过程中，请求和返回的数据是共享的；而请求重定向客户端发送两次完全不同的请求，所以两次请求中的数据是不同的。</li>
</ul>
</li>
<li><p>最终 URL 地址不同</p>
</li>
<li><ul>
<li>请求转发是服务器端代为请求，再将结果返回给客户端的，所以整个请求的过程中 URL 地址是不变的；而请求重定向是服务器端告诉客户端，“你去另一个地访问去”，所以浏览器会重新再发送一次请求，因此客户端最终显示的 URL 也为最终跳转的地址，而非刚开始请求的地址，所以 URL 地址发生了改变。</li>
</ul>
</li>
<li><p>代码实现不同</p>
</li>
<li><ul>
<li>重定向response.sendRedirect(“&#x2F;index.html”);</li>
<li>转发request.getRequestDispatcher(“&#x2F;index.html”).forward(request, response);</li>
</ul>
</li>
</ul>
</li>
<li><p>应用层</p>
</li>
<li><ul>
<li>常见协议：HTTP、SMTP、POP3&#x2F;IMAP、FTP、Telnet、SSH、RTP、DNS</li>
<li>HTTP</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>无状态怎么保存状态</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>HTTP是一种无状态协议，自身不对请求和响应之间的通信状态进行保存，而是通过Session机制进行解决，Session的作用就是通过服务端记录用户的状态。</li>
<li>保存Session的方法有很多，常用的就是内存和数据库，如Redis。</li>
<li>但Session存放在服务端，如何实现Session跟踪呢，大部分情况下通过在Cookie中附加一个Session ID来进行跟踪。</li>
<li>Cookie 被禁用的时候利用URL把Session ID直接附加在URL路径后面。</li>
</ul>
</li>
<li><p>常见字段</p>
</li>
<li><ul>
<li>Host 字段：客户端发送请求时，用来指定服务器的域名。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><p>Content-Length 字段：服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</p>
</li>
<li><p>Connection 字段： Connection 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
</li>
<li><ul>
<li>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</li>
</ul>
</li>
<li><p>Content-Type 字段： Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
</li>
<li><p>Content-Encoding 字段： Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>HTTPS</li>
<li>HTTP和HTTPS的区别</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>http</p>
</li>
<li><ul>
<li>默认端口使用80</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>http协议运行在TCP上，所有传输的内容是明文的，客户端和服务器都无法验证对方的身份。</li>
<li>安全性低，消耗更少资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>https</p>
</li>
<li><ul>
<li>默认端口使用443</li>
<li>https是运行在SSL上的http协议，而ssl运行在tcp上。采用的是混合加密的方式，所有传输内容都通过对称加密的方式。但是对称加密的秘钥用服务器方的证书进行了非对称加密。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>安全性高，消耗更多资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传输层</p>
</li>
<li><ul>
<li><p>常见协议：TCP、UDP、CDN</p>
</li>
<li><p>TCP</p>
</li>
<li><ul>
<li><p>唯一确定一个连接</p>
</li>
<li><ul>
<li>源地址、源端口、目的地址、目的端口</li>
</ul>
</li>
<li><p>头格式</p>
</li>
<li><ul>
<li><p>序列号</p>
</li>
<li><p>确认应答号</p>
</li>
<li><p>控制位</p>
</li>
<li><ul>
<li>ACK：为1时候</li>
</ul>
</li>
</ul>
</li>
<li><p>三次握手</p>
</li>
<li><ul>
<li><p>刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后</p>
</li>
<li><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
</li>
<li><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
</li>
<li><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</li>
<li><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
</li>
<li><p>过程</p>
</li>
<li><ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 </li>
<li>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。 </li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
</li>
<li><p>作用</p>
</li>
<li><ul>
<li>确认双方的发送接受能力</li>
<li>确定自己的初始化序列号，可靠传输做准备</li>
<li>数字证书的验证，加密密钥的生成。</li>
</ul>
</li>
<li><p>三次握手目的</p>
</li>
<li><ul>
<li>建立可靠的通信信道，双方确认自己与对方的发送与接收是正常的。确认双方的接收与发送能力是否正常。</li>
</ul>
</li>
<li><p>第三次握手的原因</p>
</li>
<li><ul>
<li>防止失效的连接请求到达服务器，让服务器错误打开连接。</li>
</ul>
</li>
</ul>
</li>
<li><p>四次挥手</p>
</li>
<li><ul>
<li><p>过程</p>
</li>
<li><ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</li>
<li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态 5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
</li>
<li><p>等待2MSL原因</p>
</li>
<li><ul>
<li>MSL（Maximum Segment Lifetime）是预期TCP段在网络中存在的最长时间（以秒为单位）。</li>
<li>1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端</li>
<li>1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达</li>
</ul>
</li>
<li><p>客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭</p>
</li>
<li><ul>
<li>一是为了让B能够按照正常步骤进入CLOSED状态</li>
<li>二是为了防止已经失效的请求连接报文出现在下次连接中。</li>
<li>确保服务器是否已经收到ACK 报文，没有收到会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</li>
</ul>
</li>
<li><p>第四次挥手的原因</p>
</li>
<li><ul>
<li>服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</li>
</ul>
</li>
</ul>
</li>
<li><p>保证可靠性</p>
</li>
<li><ul>
<li>TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。</li>
<li>连接断开三次握手四次挥手</li>
<li>有状态，记录哪些数据发送和接收。保证数据包按时到达，不传错。</li>
<li>确认和重传机制，建立连接时三次握手同步 序列号+确认号+窗口大小信息是基础。过程中若checkSum校验失败、丢包或延时发送端重传。</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>防止过多的数据注入到网络中</li>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>重传机制</p>
</li>
<li><ul>
<li>基于时间、基于确认信息的两种独立机制。发送一个数据之后就开启一个定时器，若这个时间内没有ACK确认报文就重传，达到一定次数没成功就放弃并发送一个复位信号。</li>
<li>数据包丢失，确认应答丢失时发生超时重传</li>
</ul>
</li>
<li><p>滑动窗口</p>
</li>
<li><ul>
<li>实现流量控制，控制发送速率保证接收方来得及接收。</li>
<li>TCP双方各维护一个发送窗口和接收窗口。接收窗口大小取决于应用系统硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p>UDP</p>
</li>
<li><p>TCP UDP区别</p>
</li>
<li><ul>
<li><p>TCP</p>
</li>
<li><ul>
<li>面向连接（（如打电话要先拨号建立连接）;</li>
<li>要求安全性，提供可靠的服务，通过TCP连接传送的数据，不丢失、不重复、安全可靠。</li>
<li>点对点连接的。</li>
<li>传输效率相对较低。</li>
<li>适合用于网页，邮件等。</li>
<li>面向字节流。</li>
<li>常用的应用层协议有：HTTP，FTP，SMTP，TELNET，SSH</li>
</ul>
</li>
<li><p>UDP</p>
</li>
<li><ul>
<li>是无连接的，即发送数据之前不需要建立连接。</li>
<li>尽最大努力交付，即不保证可靠交付。</li>
<li>一对一，一对多，多对多都可以。</li>
<li>传输效率高，它适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>适合用于视频，语音广播等。</li>
<li>面向报文。</li>
<li>常用的应用层协议有：DNS，TFTP，SNMP</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP和UDP的区别</p>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>连接</p>
</li>
<li><ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
</li>
<li><p>服务对象</p>
</li>
<li><ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
</li>
<li><p>可靠性</p>
</li>
<li><ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。</li>
</ul>
</li>
<li><p>拥塞控制、流量控制</p>
</li>
<li><ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
</li>
<li><p>首部开销</p>
</li>
<li><ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 </li>
<li>20 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
</li>
<li><p>传输方式</p>
</li>
<li><ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
</li>
<li><p>分片不同</p>
</li>
<li><ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN    内容分发网络</p>
</li>
<li><ul>
<li>一种分布式的网络架构，它可以将互联网上的内容，如文本、图片、音频、视频等，存储在离用户更近的节点上，以提高用户访问这些内容的速度和体验。</li>
<li>CDN节点通常由不同的提供商运营，并分布在全球各地的数据中心中。</li>
</ul>
</li>
</ul>
</li>
<li><p>网络层</p>
</li>
<li><ul>
<li>IP</li>
</ul>
</li>
<li><ul>
<li><p>DNS</p>
</li>
<li><ul>
<li><p>将要访问的域名解析出对应的IP地址。</p>
</li>
<li><p>步骤</p>
</li>
<li><ul>
<li>搜索浏览器自带的dns缓存；</li>
<li>查询操作系统缓存和hosts静态解析；</li>
<li>查询本地dns服务器</li>
<li>查询根dns服务器</li>
<li>查询顶级域dns服务器</li>
<li>查询权威dns服务器</li>
<li>本地dns服务器缓存该条解析记录</li>
</ul>
</li>
</ul>
</li>
<li><p>ARP</p>
</li>
<li><p>DHCP</p>
</li>
<li><p>NAT</p>
</li>
</ul>
</li>
<li><p>数据链路层</p>
</li>
<li><p>- </p>
</li>
<li><p>物理层</p>
</li>
<li><ul>
<li>ARP</li>
</ul>
</li>
<li><p>WebSocket</p>
</li>
<li><ul>
<li><p>全双工通信协议，在TCP连接上进行通信，属应用层协议，只需一次握手可创建持久性的连接进行双向数据传输。</p>
</li>
<li><p>双向通信方式</p>
</li>
<li><ul>
<li><p>Ajax短轮询</p>
</li>
<li><ul>
<li>浏览器周期性发起HTTP请求，不管是否收到都会向浏览器返回响应。</li>
<li>HTTP请求头每次需带请求头，浪费大量带宽和CPU资源。</li>
</ul>
</li>
<li><p>Long Poll长轮询</p>
</li>
<li><ul>
<li>服务端阻塞模型进行轮询，没消息就阻塞不立即响应。服务端有消息响应后发送下一轮轮询请求。</li>
</ul>
</li>
<li><p>WebSocket</p>
</li>
<li><ul>
<li><p>握手阶段使用HTTP</p>
</li>
<li><p>与HTTP区别在于</p>
</li>
<li><ul>
<li>双向通信协议，CS都可以主动发送接受。</li>
<li>建立连接的前提需要HTTP，后续通信不需。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TELNET</p>
</li>
<li><ul>
<li>网络电传，默认端口23</li>
</ul>
</li>
<li><p>TFTP-Trivial File Transfer Protocol </p>
</li>
<li><ul>
<li>简单文件传输协议，底层UDP，默认端口69</li>
</ul>
</li>
<li><p>SNMP-Simple Network Management Protocol</p>
</li>
<li><ul>
<li>简单网络管理协议，底层UDP，通过UDP端口161接收，只有Trap信息采用UDP端口162。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://alittlebitcool.github.io">YuXingZh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://alittlebitcool.github.io/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://alittlebitcool.github.io/2023/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://alittlebitcool.github.io" target="_blank">YuXingZh Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">操作系统</div></div><div class="info-2"><div class="info-item-1"> 分层结构   分层为了每一层专注一件事，相互独立，提高灵活性可替换性。    分层结构   应用层   任务：为计算机提供服务          传输单位：报文         表示层        任务：数据处理(编解码、加密解密、压缩解压缩) 功能：文件传输，访问和管理 协议：FTP，SMTP，DHCP          传输单位：报文         会话层   任务：管理 (建立、维护、重连)应用程序之间的会话          传输单位：报文         传输层：        任务：负责主机两个进程之间的通信          功能：端到端提供可靠传输服务，提供流量控制，差错控制，服务质量等管理服务。 协议：TCP，UDP          传输单位：报文段         网络层：        任务：路由和寻址(决定数据在网络的游走路径）          实现主机与主机之间的通信，也叫点对点（end to...</div></div></div></a><a class="pagination-related" href="/2023/05/08/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" title="消息系统分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">消息系统分析</div></div><div class="info-2"><div class="info-item-1">依赖的中间件：网关、数据库、缓存、消息队列、冷热库存储 需要考虑的点：如何收发消息（推&#x2F;拉），消息如何聚合（多条消息聚合成一个通知提醒） 加分点：按照场景存储消息（点赞&#x2F;私信&#x2F;广告），冷热库 </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YuXingZh</div><div class="author-info-description">欢迎来到YuXingZh的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/12/feed%E6%B5%81%E5%88%86%E6%9E%90/" title="feed流分析">feed流分析</a><time datetime="2025-03-12T09:24:27.000Z" title="发表于 2025-03-12 17:24:27">2025-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93-%E7%BB%93%E6%9E%84%E5%9E%8B/" title="设计模式总结-结构型">设计模式总结-结构型</a><time datetime="2025-03-02T11:15:19.000Z" title="发表于 2025-03-02 19:15:19">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93-%E8%A1%8C%E4%B8%BA%E5%9E%8B/" title="设计模式总结-行为型">设计模式总结-行为型</a><time datetime="2025-03-02T11:15:16.000Z" title="发表于 2025-03-02 19:15:16">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93-%E5%88%9B%E5%BB%BA%E5%9E%8B/" title="设计模式总结-创建型">设计模式总结-创建型</a><time datetime="2025-03-02T11:14:54.000Z" title="发表于 2025-03-02 19:14:54">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/" title="红包系统分析">红包系统分析</a><time datetime="2025-02-17T11:23:49.000Z" title="发表于 2025-02-17 19:23:49">2025-02-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By YuXingZh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.2.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>